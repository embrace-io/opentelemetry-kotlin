package io.embrace.opentelemetry.kotlin.semconv

/**
 * Autogenerated OpenTelemetry semantic conventions for 'k8s'.
 *
 * DO NOT EDIT - AUTOGENERATED FILE
 */
@Suppress("unused")
object K8sAttributes {
  

    /**
    * <p>The name of the cluster.</p>
    */
    @IncubatingApi
    const val K8S_CLUSTER_NAME: String = "k8s.cluster.name"

    /**
    * <p>A pseudo-ID for the cluster, set to the UID of the <c>kube-system</c> namespace.</p>
    * <p>Notes:</p>
    * <p>K8s doesn't have support for obtaining a cluster ID. If this is ever
    * added, we will recommend collecting the <c>k8s.cluster.uid</c> through the
    * official APIs. In the meantime, we are able to use the <c>uid</c> of the
    * <c>kube-system</c> namespace as a proxy for cluster ID. Read on for the
    * rationale.</p>
    * <p>Every object created in a K8s cluster is assigned a distinct UID. The
    * <c>kube-system</c> namespace is used by Kubernetes itself and will exist
    * for the lifetime of the cluster. Using the <c>uid</c> of the <c>kube-system</c>
    * namespace is a reasonable proxy for the K8s ClusterID as it will only
    * change if the cluster is rebuilt. Furthermore, Kubernetes UIDs are
    * UUIDs as standardized by
    * <a href="https://www.itu.int/ITU-T/studygroups/com17/oid.html">ISO/IEC 9834-8 and ITU-T X.667</a>.
    * Which states:</p>
    * <blockquote>
    * <p>If generated according to one of the mechanisms defined in Rec.
    * ITU-T X.667 | ISO/IEC 9834-8, a UUID is either guaranteed to be
    * different from all other UUIDs generated before 3603 A.D., or is
    * extremely likely to be different (depending on the mechanism chosen).</p></blockquote>
    * <p>Therefore, UIDs between clusters should be extremely unlikely to
    * conflict.</p>
    */
    @IncubatingApi
    const val K8S_CLUSTER_UID: String = "k8s.cluster.uid"

    /**
    * <p>The name of the Container from Pod specification, must be unique within a Pod. Container runtime usually uses different globally unique name (<c>container.name</c>).</p>
    */
    @IncubatingApi
    const val K8S_CONTAINER_NAME: String = "k8s.container.name"

    /**
    * <p>Number of times the container was restarted. This attribute can be used to identify a particular container (running or stopped) within a container spec.</p>
    */
    @IncubatingApi
    const val K8S_CONTAINER_RESTART_COUNT: String = "k8s.container.restart_count"

    /**
    * <p>Last terminated reason of the Container.</p>
    */
    @IncubatingApi
    const val K8S_CONTAINER_STATUS_LAST_TERMINATED_REASON: String = "k8s.container.status.last_terminated_reason"

    /**
    * <p>The reason for the container state. Corresponds to the <c>reason</c> field of the: <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#containerstatewaiting-v1-core">K8s ContainerStateWaiting</a> or <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#containerstateterminated-v1-core">K8s ContainerStateTerminated</a></p>
    */
    @IncubatingApi
    const val K8S_CONTAINER_STATUS_REASON: String = "k8s.container.status.reason"

    /**
    * <p>The state of the container. <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#containerstate-v1-core">K8s ContainerState</a></p>
    */
    @IncubatingApi
    const val K8S_CONTAINER_STATUS_STATE: String = "k8s.container.status.state"

    /**
    * <p>The cronjob annotation placed on the CronJob, the <c><key></c> being the annotation name, the value being the annotation value.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>An annotation <c>retries</c> with value <c>4</c> SHOULD be recorded as the
    * <c>k8s.cronjob.annotation.retries</c> attribute with value <c>"4"</c>.</li>
    *   <li>An annotation <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.cronjob.annotation.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_CRONJOB_ANNOTATION: String = "k8s.cronjob.annotation"

    /**
    * <p>The label placed on the CronJob, the <c><key></c> being the label name, the value being the label value.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>type</c> with value <c>weekly</c> SHOULD be recorded as the
    * <c>k8s.cronjob.label.type</c> attribute with value <c>"weekly"</c>.</li>
    *   <li>A label <c>automated</c> with empty string value SHOULD be recorded as
    * the <c>k8s.cronjob.label.automated</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_CRONJOB_LABEL: String = "k8s.cronjob.label"

    /**
    * <p>The name of the CronJob.</p>
    */
    @IncubatingApi
    const val K8S_CRONJOB_NAME: String = "k8s.cronjob.name"

    /**
    * <p>The UID of the CronJob.</p>
    */
    @IncubatingApi
    const val K8S_CRONJOB_UID: String = "k8s.cronjob.uid"

    /**
    * <p>The annotation placed on the DaemonSet, the <c><key></c> being the annotation name, the value being the annotation value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>replicas</c> with value <c>1</c> SHOULD be recorded
    * as the <c>k8s.daemonset.annotation.replicas</c> attribute with value <c>"1"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.daemonset.annotation.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_DAEMONSET_ANNOTATION: String = "k8s.daemonset.annotation"

    /**
    * <p>The label placed on the DaemonSet, the <c><key></c> being the label name, the value being the label value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>app</c> with value <c>guestbook</c> SHOULD be recorded
    * as the <c>k8s.daemonset.label.app</c> attribute with value <c>"guestbook"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.daemonset.label.injected</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_DAEMONSET_LABEL: String = "k8s.daemonset.label"

    /**
    * <p>The name of the DaemonSet.</p>
    */
    @IncubatingApi
    const val K8S_DAEMONSET_NAME: String = "k8s.daemonset.name"

    /**
    * <p>The UID of the DaemonSet.</p>
    */
    @IncubatingApi
    const val K8S_DAEMONSET_UID: String = "k8s.daemonset.uid"

    /**
    * <p>The annotation placed on the Deployment, the <c><key></c> being the annotation name, the value being the annotation value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>replicas</c> with value <c>1</c> SHOULD be recorded
    * as the <c>k8s.deployment.annotation.replicas</c> attribute with value <c>"1"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.deployment.annotation.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_DEPLOYMENT_ANNOTATION: String = "k8s.deployment.annotation"

    /**
    * <p>The label placed on the Deployment, the <c><key></c> being the label name, the value being the label value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>replicas</c> with value <c>0</c> SHOULD be recorded
    * as the <c>k8s.deployment.label.app</c> attribute with value <c>"guestbook"</c>.</li>
    *   <li>A label <c>injected</c> with empty string value SHOULD be recorded as
    * the <c>k8s.deployment.label.injected</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_DEPLOYMENT_LABEL: String = "k8s.deployment.label"

    /**
    * <p>The name of the Deployment.</p>
    */
    @IncubatingApi
    const val K8S_DEPLOYMENT_NAME: String = "k8s.deployment.name"

    /**
    * <p>The UID of the Deployment.</p>
    */
    @IncubatingApi
    const val K8S_DEPLOYMENT_UID: String = "k8s.deployment.uid"

    /**
    * <p>The type of metric source for the horizontal pod autoscaler.</p>
    * <p>Notes:</p>
    * <p>This attribute reflects the <c>type</c> field of spec.metrics[] in the HPA.</p>
    */
    @IncubatingApi
    const val K8S_HPA_METRIC_TYPE: String = "k8s.hpa.metric.type"

    /**
    * <p>The name of the horizontal pod autoscaler.</p>
    */
    @IncubatingApi
    const val K8S_HPA_NAME: String = "k8s.hpa.name"

    /**
    * <p>The API version of the target resource to scale for the HorizontalPodAutoscaler.</p>
    * <p>Notes:</p>
    * <p>This maps to the <c>apiVersion</c> field in the <c>scaleTargetRef</c> of the HPA spec.</p>
    */
    @IncubatingApi
    const val K8S_HPA_SCALETARGETREF_API_VERSION: String = "k8s.hpa.scaletargetref.api_version"

    /**
    * <p>The kind of the target resource to scale for the HorizontalPodAutoscaler.</p>
    * <p>Notes:</p>
    * <p>This maps to the <c>kind</c> field in the <c>scaleTargetRef</c> of the HPA spec.</p>
    */
    @IncubatingApi
    const val K8S_HPA_SCALETARGETREF_KIND: String = "k8s.hpa.scaletargetref.kind"

    /**
    * <p>The name of the target resource to scale for the HorizontalPodAutoscaler.</p>
    * <p>Notes:</p>
    * <p>This maps to the <c>name</c> field in the <c>scaleTargetRef</c> of the HPA spec.</p>
    */
    @IncubatingApi
    const val K8S_HPA_SCALETARGETREF_NAME: String = "k8s.hpa.scaletargetref.name"

    /**
    * <p>The UID of the horizontal pod autoscaler.</p>
    */
    @IncubatingApi
    const val K8S_HPA_UID: String = "k8s.hpa.uid"

    /**
    * <p>The size (identifier) of the K8s huge page.</p>
    */
    @IncubatingApi
    const val K8S_HUGEPAGE_SIZE: String = "k8s.hugepage.size"

    /**
    * <p>The annotation placed on the Job, the <c><key></c> being the annotation name, the value being the annotation value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>number</c> with value <c>1</c> SHOULD be recorded
    * as the <c>k8s.job.annotation.number</c> attribute with value <c>"1"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.job.annotation.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_JOB_ANNOTATION: String = "k8s.job.annotation"

    /**
    * <p>The label placed on the Job, the <c><key></c> being the label name, the value being the label value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>jobtype</c> with value <c>ci</c> SHOULD be recorded
    * as the <c>k8s.job.label.jobtype</c> attribute with value <c>"ci"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.job.label.automated</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_JOB_LABEL: String = "k8s.job.label"

    /**
    * <p>The name of the Job.</p>
    */
    @IncubatingApi
    const val K8S_JOB_NAME: String = "k8s.job.name"

    /**
    * <p>The UID of the Job.</p>
    */
    @IncubatingApi
    const val K8S_JOB_UID: String = "k8s.job.uid"

    /**
    * <p>The annotation placed on the Namespace, the <c><key></c> being the annotation name, the value being the annotation value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>ttl</c> with value <c>0</c> SHOULD be recorded
    * as the <c>k8s.namespace.annotation.ttl</c> attribute with value <c>"0"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.namespace.annotation.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_NAMESPACE_ANNOTATION: String = "k8s.namespace.annotation"

    /**
    * <p>The label placed on the Namespace, the <c><key></c> being the label name, the value being the label value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>kubernetes.io/metadata.name</c> with value <c>default</c> SHOULD be recorded
    * as the <c>k8s.namespace.label.kubernetes.io/metadata.name</c> attribute with value <c>"default"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.namespace.label.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_NAMESPACE_LABEL: String = "k8s.namespace.label"

    /**
    * <p>The name of the namespace that the pod is running in.</p>
    */
    @IncubatingApi
    const val K8S_NAMESPACE_NAME: String = "k8s.namespace.name"

    /**
    * <p>The phase of the K8s namespace.</p>
    * <p>Notes:</p>
    * <p>This attribute aligns with the <c>phase</c> field of the
    * <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#namespacestatus-v1-core">K8s NamespaceStatus</a></p>
    */
    @IncubatingApi
    const val K8S_NAMESPACE_PHASE: String = "k8s.namespace.phase"

    /**
    * <p>The annotation placed on the Node, the <c><key></c> being the annotation name, the value being the annotation value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>An annotation <c>node.alpha.kubernetes.io/ttl</c> with value <c>0</c> SHOULD be recorded as
    * the <c>k8s.node.annotation.node.alpha.kubernetes.io/ttl</c> attribute with value <c>"0"</c>.</li>
    *   <li>An annotation <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.node.annotation.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_NODE_ANNOTATION: String = "k8s.node.annotation"

    /**
    * <p>The status of the condition, one of True, False, Unknown.</p>
    * <p>Notes:</p>
    * <p>This attribute aligns with the <c>status</c> field of the
    * <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#nodecondition-v1-core">NodeCondition</a></p>
    */
    @IncubatingApi
    const val K8S_NODE_CONDITION_STATUS: String = "k8s.node.condition.status"

    /**
    * <p>The condition type of a K8s Node.</p>
    * <p>Notes:</p>
    * <p>K8s Node conditions as described
    * by <a href="https://v1-32.docs.kubernetes.io/docs/reference/node/node-status/#condition">K8s documentation</a>.</p>
    * <p>This attribute aligns with the <c>type</c> field of the
    * <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#nodecondition-v1-core">NodeCondition</a></p>
    * <p>The set of possible values is not limited to those listed here. Managed Kubernetes environments,
    * or custom controllers MAY introduce additional node condition types.
    * When this occurs, the exact value as reported by the Kubernetes API SHOULD be used.</p>
    */
    @IncubatingApi
    const val K8S_NODE_CONDITION_TYPE: String = "k8s.node.condition.type"

    /**
    * <p>The label placed on the Node, the <c><key></c> being the label name, the value being the label value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>kubernetes.io/arch</c> with value <c>arm64</c> SHOULD be recorded
    * as the <c>k8s.node.label.kubernetes.io/arch</c> attribute with value <c>"arm64"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.node.label.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_NODE_LABEL: String = "k8s.node.label"

    /**
    * <p>The name of the Node.</p>
    */
    @IncubatingApi
    const val K8S_NODE_NAME: String = "k8s.node.name"

    /**
    * <p>The UID of the Node.</p>
    */
    @IncubatingApi
    const val K8S_NODE_UID: String = "k8s.node.uid"

    /**
    * <p>The annotation placed on the Pod, the <c><key></c> being the annotation name, the value being the annotation value.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>An annotation <c>kubernetes.io/enforce-mountable-secrets</c> with value <c>true</c> SHOULD be recorded as
    * the <c>k8s.pod.annotation.kubernetes.io/enforce-mountable-secrets</c> attribute with value <c>"true"</c>.</li>
    *   <li>An annotation <c>mycompany.io/arch</c> with value <c>x64</c> SHOULD be recorded as
    * the <c>k8s.pod.annotation.mycompany.io/arch</c> attribute with value <c>"x64"</c>.</li>
    *   <li>An annotation <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.pod.annotation.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_POD_ANNOTATION: String = "k8s.pod.annotation"

    /**
    * <p>The label placed on the Pod, the <c><key></c> being the label name, the value being the label value.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>app</c> with value <c>my-app</c> SHOULD be recorded as
    * the <c>k8s.pod.label.app</c> attribute with value <c>"my-app"</c>.</li>
    *   <li>A label <c>mycompany.io/arch</c> with value <c>x64</c> SHOULD be recorded as
    * the <c>k8s.pod.label.mycompany.io/arch</c> attribute with value <c>"x64"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.pod.label.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_POD_LABEL: String = "k8s.pod.label"

    /**
    * <p>Deprecated, use <c>k8s.pod.label</c> instead.</p>
    */
    @Deprecated("Replaced by `k8s.pod.label`.")
    const val K8S_POD_LABELS: String = "k8s.pod.labels"

    /**
    * <p>The name of the Pod.</p>
    */
    @IncubatingApi
    const val K8S_POD_NAME: String = "k8s.pod.name"

    /**
    * <p>The UID of the Pod.</p>
    */
    @IncubatingApi
    const val K8S_POD_UID: String = "k8s.pod.uid"

    /**
    * <p>The annotation placed on the ReplicaSet, the <c><key></c> being the annotation name, the value being the annotation value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>replicas</c> with value <c>0</c> SHOULD be recorded
    * as the <c>k8s.replicaset.annotation.replicas</c> attribute with value <c>"0"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.replicaset.annotation.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_REPLICASET_ANNOTATION: String = "k8s.replicaset.annotation"

    /**
    * <p>The label placed on the ReplicaSet, the <c><key></c> being the label name, the value being the label value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>app</c> with value <c>guestbook</c> SHOULD be recorded
    * as the <c>k8s.replicaset.label.app</c> attribute with value <c>"guestbook"</c>.</li>
    *   <li>A label <c>injected</c> with empty string value SHOULD be recorded as
    * the <c>k8s.replicaset.label.injected</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_REPLICASET_LABEL: String = "k8s.replicaset.label"

    /**
    * <p>The name of the ReplicaSet.</p>
    */
    @IncubatingApi
    const val K8S_REPLICASET_NAME: String = "k8s.replicaset.name"

    /**
    * <p>The UID of the ReplicaSet.</p>
    */
    @IncubatingApi
    const val K8S_REPLICASET_UID: String = "k8s.replicaset.uid"

    /**
    * <p>The name of the replication controller.</p>
    */
    @IncubatingApi
    const val K8S_REPLICATIONCONTROLLER_NAME: String = "k8s.replicationcontroller.name"

    /**
    * <p>The UID of the replication controller.</p>
    */
    @IncubatingApi
    const val K8S_REPLICATIONCONTROLLER_UID: String = "k8s.replicationcontroller.uid"

    /**
    * <p>The name of the resource quota.</p>
    */
    @IncubatingApi
    const val K8S_RESOURCEQUOTA_NAME: String = "k8s.resourcequota.name"

    /**
    * <p>The name of the K8s resource a resource quota defines.</p>
    * <p>Notes:</p>
    * <p>The value for this attribute can be either the full <c>count/<resource>[.<group>]</c> string (e.g., count/deployments.apps, count/pods), or, for certain core Kubernetes resources, just the resource name (e.g., pods, services, configmaps). Both forms are supported by Kubernetes for object count quotas. See <a href="https://kubernetes.io/docs/concepts/policy/resource-quotas/#object-count-quota">Kubernetes Resource Quotas documentation</a> for more details.</p>
    */
    @IncubatingApi
    const val K8S_RESOURCEQUOTA_RESOURCE_NAME: String = "k8s.resourcequota.resource_name"

    /**
    * <p>The UID of the resource quota.</p>
    */
    @IncubatingApi
    const val K8S_RESOURCEQUOTA_UID: String = "k8s.resourcequota.uid"

    /**
    * <p>The annotation placed on the StatefulSet, the <c><key></c> being the annotation name, the value being the annotation value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>replicas</c> with value <c>1</c> SHOULD be recorded
    * as the <c>k8s.statefulset.annotation.replicas</c> attribute with value <c>"1"</c>.</li>
    *   <li>A label <c>data</c> with empty string value SHOULD be recorded as
    * the <c>k8s.statefulset.annotation.data</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_STATEFULSET_ANNOTATION: String = "k8s.statefulset.annotation"

    /**
    * <p>The label placed on the StatefulSet, the <c><key></c> being the label name, the value being the label value, even if the value is empty.</p>
    * <p>Notes:</p>
    * <p>Examples:</p>
    * <ul>
    *   <li>A label <c>replicas</c> with value <c>0</c> SHOULD be recorded
    * as the <c>k8s.statefulset.label.app</c> attribute with value <c>"guestbook"</c>.</li>
    *   <li>A label <c>injected</c> with empty string value SHOULD be recorded as
    * the <c>k8s.statefulset.label.injected</c> attribute with value <c>""</c>.</li>
    * </ul>
    */
    @IncubatingApi
    const val K8S_STATEFULSET_LABEL: String = "k8s.statefulset.label"

    /**
    * <p>The name of the StatefulSet.</p>
    */
    @IncubatingApi
    const val K8S_STATEFULSET_NAME: String = "k8s.statefulset.name"

    /**
    * <p>The UID of the StatefulSet.</p>
    */
    @IncubatingApi
    const val K8S_STATEFULSET_UID: String = "k8s.statefulset.uid"

    /**
    * <p>The name of K8s <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#storageclass-v1-storage-k8s-io">StorageClass</a> object.</p>
    */
    @IncubatingApi
    const val K8S_STORAGECLASS_NAME: String = "k8s.storageclass.name"

    /**
    * <p>The name of the K8s volume.</p>
    */
    @IncubatingApi
    const val K8S_VOLUME_NAME: String = "k8s.volume.name"

    /**
    * <p>The type of the K8s volume.</p>
    */
    @IncubatingApi
    const val K8S_VOLUME_TYPE: String = "k8s.volume.type"

    /**
    * <p>K8S_CONTAINER_STATUS_REASON</p>
    */
    @IncubatingApi
    enum class K8sContainerStatusReasonValues(val value: String) {

        /**
        * <p>The container is being created.</p>
        */
        CONTAINER_CREATING("ContainerCreating"),

        /**
        * <p>The container is in a crash loop back off state.</p>
        */
        CRASH_LOOP_BACK_OFF("CrashLoopBackOff"),

        /**
        * <p>There was an error creating the container configuration.</p>
        */
        CREATE_CONTAINER_CONFIG_ERROR("CreateContainerConfigError"),

        /**
        * <p>There was an error pulling the container image.</p>
        */
        ERR_IMAGE_PULL("ErrImagePull"),

        /**
        * <p>The container image pull is in back off state.</p>
        */
        IMAGE_PULL_BACK_OFF("ImagePullBackOff"),

        /**
        * <p>The container was killed due to out of memory.</p>
        */
        OOM_KILLED("OOMKilled"),

        /**
        * <p>The container has completed execution.</p>
        */
        COMPLETED("Completed"),

        /**
        * <p>There was an error with the container.</p>
        */
        ERROR("Error"),

        /**
        * <p>The container cannot run.</p>
        */
        CONTAINER_CANNOT_RUN("ContainerCannotRun"),
    }

    /**
    * <p>K8S_CONTAINER_STATUS_STATE</p>
    */
    @IncubatingApi
    enum class K8sContainerStatusStateValues(val value: String) {

        /**
        * <p>The container has terminated.</p>
        */
        TERMINATED("terminated"),

        /**
        * <p>The container is running.</p>
        */
        RUNNING("running"),

        /**
        * <p>The container is waiting.</p>
        */
        WAITING("waiting"),
    }

    /**
    * <p>K8S_NAMESPACE_PHASE</p>
    */
    @IncubatingApi
    enum class K8sNamespacePhaseValues(val value: String) {

        /**
        * <p>Active namespace phase as described by <a href="https://pkg.go.dev/k8s.io/api@v0.31.3/core/v1#NamespacePhase">K8s API</a></p>
        */
        ACTIVE("active"),

        /**
        * <p>Terminating namespace phase as described by <a href="https://pkg.go.dev/k8s.io/api@v0.31.3/core/v1#NamespacePhase">K8s API</a></p>
        */
        TERMINATING("terminating"),
    }

    /**
    * <p>K8S_NODE_CONDITION_STATUS</p>
    */
    @IncubatingApi
    enum class K8sNodeConditionStatusValues(val value: String) {

        /**
        * <p>condition_true.</p>
        */
        CONDITION_TRUE("true"),

        /**
        * <p>condition_false.</p>
        */
        CONDITION_FALSE("false"),

        /**
        * <p>condition_unknown.</p>
        */
        CONDITION_UNKNOWN("unknown"),
    }

    /**
    * <p>K8S_NODE_CONDITION_TYPE</p>
    */
    @IncubatingApi
    enum class K8sNodeConditionTypeValues(val value: String) {

        /**
        * <p>The node is healthy and ready to accept pods</p>
        */
        READY("Ready"),

        /**
        * <p>Pressure exists on the disk size—that is, if the disk capacity is low</p>
        */
        DISK_PRESSURE("DiskPressure"),

        /**
        * <p>Pressure exists on the node memory—that is, if the node memory is low</p>
        */
        MEMORY_PRESSURE("MemoryPressure"),

        /**
        * <p>Pressure exists on the processes—that is, if there are too many processes on the node</p>
        */
        PID_PRESSURE("PIDPressure"),

        /**
        * <p>The network for the node is not correctly configured</p>
        */
        NETWORK_UNAVAILABLE("NetworkUnavailable"),
    }

    /**
    * <p>K8S_VOLUME_TYPE</p>
    */
    @IncubatingApi
    enum class K8sVolumeTypeValues(val value: String) {

        /**
        * <p>A <a href="https://v1-30.docs.kubernetes.io/docs/concepts/storage/volumes/#persistentvolumeclaim">persistentVolumeClaim</a> volume</p>
        */
        PERSISTENT_VOLUME_CLAIM("persistentVolumeClaim"),

        /**
        * <p>A <a href="https://v1-30.docs.kubernetes.io/docs/concepts/storage/volumes/#configmap">configMap</a> volume</p>
        */
        CONFIG_MAP("configMap"),

        /**
        * <p>A <a href="https://v1-30.docs.kubernetes.io/docs/concepts/storage/volumes/#downwardapi">downwardAPI</a> volume</p>
        */
        DOWNWARD_API("downwardAPI"),

        /**
        * <p>An <a href="https://v1-30.docs.kubernetes.io/docs/concepts/storage/volumes/#emptydir">emptyDir</a> volume</p>
        */
        EMPTY_DIR("emptyDir"),

        /**
        * <p>A <a href="https://v1-30.docs.kubernetes.io/docs/concepts/storage/volumes/#secret">secret</a> volume</p>
        */
        SECRET("secret"),

        /**
        * <p>A <a href="https://v1-30.docs.kubernetes.io/docs/concepts/storage/volumes/#local">local</a> volume</p>
        */
        LOCAL("local"),
    }
}
