package io.embrace.opentelemetry.kotlin.semconv

/**
 * Autogenerated OpenTelemetry semantic conventions for 'error'.
 *
 * DO NOT EDIT - AUTOGENERATED FILE
 */
@Suppress("unused")
object ErrorAttributes {
  

    /**
    * <p>A message providing more detail about an error in human-readable form.</p>
    * <p>Notes:</p>
    * <p><c>error.message</c> should provide additional context and detail about an error.
    * It is NOT RECOMMENDED to duplicate the value of <c>error.type</c> in <c>error.message</c>.
    * It is also NOT RECOMMENDED to duplicate the value of <c>exception.message</c> in <c>error.message</c>.</p>
    * <p><c>error.message</c> is NOT RECOMMENDED for metrics or spans due to its unbounded cardinality and overlap with span status.</p>
    */
    @IncubatingApi
    const val ERROR_MESSAGE: String = "error.message"

    /**
    * <p>Describes a class of error the operation ended with.</p>
    * <p>Notes:</p>
    * <p>The <c>error.type</c> SHOULD be predictable, and SHOULD have low cardinality.</p>
    * <p>When <c>error.type</c> is set to a type (e.g., an exception type), its
    * canonical class name identifying the type within the artifact SHOULD be used.</p>
    * <p>Instrumentations SHOULD document the list of errors they report.</p>
    * <p>The cardinality of <c>error.type</c> within one instrumentation library SHOULD be low.
    * Telemetry consumers that aggregate data from multiple instrumentation libraries and applications
    * should be prepared for <c>error.type</c> to have high cardinality at query time when no
    * additional filters are applied.</p>
    * <p>If the operation has completed successfully, instrumentations SHOULD NOT set <c>error.type</c>.</p>
    * <p>If a specific domain defines its own set of error identifiers (such as HTTP or gRPC status codes),
    * it's RECOMMENDED to:</p>
    * <ul>
    *   <li>Use a domain-specific attribute</li>
    *   <li>Set <c>error.type</c> to capture all errors, regardless of whether they are defined within the domain-specific set or not.</li>
    * </ul>
    */
    const val ERROR_TYPE: String = "error.type"

    /**
    * <p>ERROR_TYPE</p>
    */
    enum class ErrorTypeValues(val value: String) {

        /**
        * <p>A fallback error value to be used when the instrumentation doesn't define a custom value.</p>
        */
        OTHER("_OTHER"),
    }
}
